<script>class MixShaderFragment {
  constructor(uniforms) {
    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  functions() {
    if (this._main === '') {
      // if main is empty, functions can not have been computed
      this.main();
    }

    let content = '';

    for (let property in this._functions) {
      content += this._functions[property] + '\n';
    }

    return content;
  }

  uniforms() {
    let content = '';

    for (let property in this._uniforms) {
      let uniform = this._uniforms[property];
      content += `uniform ${uniform.typeGLSL} ${property}`;

      if (uniform && uniform.length) {
        content += `[${uniform.length}]`;
      }

      content += ';\n';
    }

    return content;
  }

  main() {
    // need to pre-call main to fill up the functions list
    this._main = `
void main(void) {

    vec2 texc = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,
                    ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );
  
  //The back position is the world space position stored in the texture.
  vec4 baseColor0 = texture2D(uTextureBackTest0, texc);
  vec4 baseColor1 = texture2D(uTextureBackTest1, texc);
  
  if( uTrackMouse == 1 ){

    if (uMixMode == 0) 
    {
        if (vProjectedCoords.x > uMouse.x)
        {
            gl_FragColor = baseColor0;
        }   
        else
        {
            gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );
        }
    }
    else if (uMixMode == 1)
    {
        if (vProjectedCoords.y > uMouse.y)
        {
            gl_FragColor = baseColor0;
        }   
        else
        {
            gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );
        }
    }
    else // 2
    {
        if ( (vProjectedCoords.x > uMouse.x && vProjectedCoords.y > uMouse.y) 
        || (vProjectedCoords.x < uMouse.x && vProjectedCoords.y < uMouse.y) )
        {
            gl_FragColor = baseColor0;
        }   
        else
        {
            gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );
        }
    }
  }
  else{

    if( uType1 == 0 ){

      //merge an image into
      gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );

    }
    else{

      float opacity = baseColor1.a;
      gl_FragColor = mix( baseColor0, baseColor1, opacity * uOpacity1 );

    }

  }

  return;
}
   `;
  }

  compute() {
    // let shaderInterpolation = '';
    // shaderInterpolation.inline(args) //true/false
    // shaderInterpolation.functions(args)
    return `
// uniforms
${this.uniforms()}

// varying (should fetch it from vertex directly)
// varying vec4      vPos;
varying vec4      vProjectedCoords;

// tailored functions
${this.functions()}

// main loop
${this._main}
      `;
  }

}</script>
<script>class MixShadersUniform {
  static uniforms() {
    return {
      'uTextureBackTest0': {
        type: 't',
        value: [],
        typeGLSL: 'sampler2D'
      },
      'uTextureBackTest1': {
        type: 't',
        value: [],
        typeGLSL: 'sampler2D'
      },
      'uOpacity0': {
        type: 'f',
        value: 1.0,
        typeGLSL: 'float'
      },
      'uOpacity1': {
        type: 'f',
        value: 1.0,
        typeGLSL: 'float'
      },
      'uType0': {
        type: 'i',
        value: 0,
        typeGLSL: 'int'
      },
      'uType1': {
        type: 'i',
        value: 1,
        typeGLSL: 'int'
      },
      'uTrackMouse': {
        type: 'i',
        value: 0,
        typeGLSL: 'int'
      },
      'uMouse': {
        type: 'v2',
        value: new THREE.Vector2(),
        typeGLSL: 'vec2'
      },
      'uMixMode': {
        type: 'i',
        value: 0,
        typeGLSL: 'int'
      },
      'uShift': {
        type: 'v2',
        value: new THREE.Vector2(),
        typeGLSL: 'vec2'
      },
      'uCanvasWidth': {
        type: 'f',
        value: 0.,
        typeGLSL: 'float'
      },
      'uCanvasHeight': {
        type: 'f',
        value: 0.,
        typeGLSL: 'float'
      }
    };
  }

}</script>