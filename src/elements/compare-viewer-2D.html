<link rel="import" href="../../bower_components/polymer/polymer-element.html">

<link rel="import" href="../import-ami.html">
<link rel="import" href="../shaders/import-shaders.html">

<dom-module id="compare-viewer-2d">
    <template>

    <style>
      :host {
        display: block;
        position: relative;
      }

      #container {
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        position: absolute;
        overflow: hidden;
      }

      #overlay {
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        position: absolute;
        width: 100%;
        height: 100%;
        overflow:hidden;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-align: center;
            -ms-flex-align: center;
                align-items: center;
        -webkit-box-pack: center;
            -ms-flex-pack: center;
                justify-content: center;
        pointer-events: none;

      }

      #overlay > div {
        z-index: 1;
        color: #fff;
        position: absolute;
        margin: 4px;
        padding: 2px 10px;
      }

      .direction {
        font-size: 16px;
        text-transform: uppercase;
      }

      .information {
        font-size: 14px;
      }

      .top {
        top: 0;
        text-align: center;
      }

      .bottom {
        bottom: 0;
        text-align: center;
      }

      .left {
        left: 0;
        text-align: left;
      }

      .right {
        right: 0;
        text-align: right;
      }

    </style>

    <div id="overlay">
      <div id="top" class="top direction"></div>
      <div id="bottom" class="bottom direction"></div>
      <div id="left" class="left direction"></div>
      <div id="right" class="right direction"></div>
    </div>

    <div id="container">
    </div>

    </template>

    <script>class CompareViewer2D extends Polymer.Element {
  static get is() {
    return 'compare-viewer-2d';
  }

  static get properties() {
    return {
      showInformation: {
        type: Boolean,
        value: false
      },
      animationFrameID: {
        type: Number,
        value: -1
      },
      orientation: {
        type: String,
        value: 'default',
        observer: '_orientationChanged'
      },
      stackOrientation: {
        type: Number,
        value: 0,
        notify: true
      },
      stackIndex: {
        type: Number,
        notify: true,
        observer: '_onStackIndexChanged'
      },
      stackMaxIndex: {
        type: Number
      },
      stackScene: {
        type: Object,
        value: {},
        observer: '_stackSceneChanged'
      },
      stackHelper: {
        type: Object,
        value: {}
      },
      stack2Scene: {
        type: Object,
        value: {},
        observer: '_stack2SceneChanged'
      },
      stack2Helper: {
        type: Object,
        value: {}
      },
      stackWindowWidth: {
        type: Number,
        observer: '_stackWindowWidthChanged'
      },
      stackWindowCenter: {
        type: Number,
        observer: '_stackWindowCenterChanged'
      },
      stack2WindowWidth: {
        type: Number,
        observer: '_stack2WindowWidthChanged'
      },
      stack2WindowCenter: {
        type: Number,
        observer: '_stack2WindowCenterChanged'
      },
      sceneLayerTextureTarget: {
        type: Object,
        value: {}
      },
      sceneLayer2TextureTarget: {
        type: Object,
        value: {}
      },
      offsetX: {
        type: Number,
        value: 0,
        observer: '_offsetChanged'
      },
      offsetY: {
        type: Number,
        value: 0,
        observer: '_offsetChanged'
      },
      offsetZ: {
        type: Number,
        value: 0,
        observer: '_offsetChanged'
      },
      mixMode: {
        type: Number,
        value: 2,
        observer: '_mixModeChanged'
      },
      sizeX: {
        type: Number
      },
      sizeY: {
        type: Number
      },
      mouseI: {
        type: Number
      },
      mouseJ: {
        type: Number
      },
      mouseK: {
        type: Number
      },
      mouseValue: {
        type: Number
      },
      contours: {
        type: Array,
        value: []
      },
      clipPlane: {
        type: Object,
        value: {}
      },
      localizers: {
        type: Array,
        value: [],
        observer: '_localizersChanged'
      }
    };
  }

  constructor() {
    super();
    this._onScrollBound = this._onScroll.bind(this);
    this._onMouseMoveBound = this._onMouseMove.bind(this);
    this._onDoubleClickBound = this._onDoubleClick.bind(this);
  }

  disconnectedCallback() {
    super.disconnectedCallback();

    this._controls.removeEventListener('OnScroll', this._onScrollBound);

    this._container.removeEventListener('dblclick', this._onDoubleClickBound);

    this._container.removeEventListener('mousemove', this._onMouseMoveBound);
  }

  connectedCallback() {
    super.connectedCallback();

    if (this._controls !== undefined && this._container !== undefined) {
      this._controls.addEventListener('OnScroll', this._onScrollBound);

      this._container.addEventListener('dblclick', this._onDoubleClickBound);

      this._container.addEventListener('mousemove', this._onMouseMoveBound);
    }
  }

  ready() {
    super.ready();

    this._initViewer();
  }

  _initViewer() {
    this._container = this.$.container;
    this._slice = null;
    this._scene = null;
    this._scene2 = null;
    this._clipPlane = null;
    this.stackHelper = null;
    this.stack2Helper = null;
    this.orientation = 'default';
    this._changed = true;

    this._initScene();

    this._initCamera(1);

    this._initControls();

    this._initRenderer();

    this._initLocalizers();

    this._initContours();

    this._initLayerMix(); // attach event listeners


    this._controls.addEventListener('OnScroll', this._onScrollBound);

    this._container.addEventListener('dblclick', this._onDoubleClickBound);

    this._container.addEventListener('mousemove', this._onMouseMoveBound); // add dummy cube for testing


    const geometry = new THREE.BoxGeometry(200, 200, 200);
    const material = new THREE.MeshBasicMaterial({
      color: 0xff0000,
      wireframe: true
    });
  }

  _initScene() {
    this._scene = new THREE.Scene();
    this._scene2 = new THREE.Scene();
  }

  _initCamera() {
    this._camera = new AMI.OrthographicCamera(this._container.clientWidth / -2, this._container.clientWidth / 2, this._container.clientHeight / -2, this._container.clientHeight / 2, 1, 1000);
  }

  _initControls() {
    this._controls = new AMI.TrackballOrthoControl(this._camera, this._container);
    this._controls.staticMoving = true;
    this._controls.noRotate = true;

    this._controls.target.set(0, 0, 0);

    this._camera.controls = this._controls;

    this._controls.addEventListener('change', () => {
      this._changed = true;
    });
  }

  _initRenderer() {
    this._renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    this._renderer.autoClear = false;
    this._renderer.updateStyle = true;
    this._renderer.localClippingEnabled = true;

    this._renderer.setClearColor(0x424242); // background color


    this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);

    this._container.appendChild(this._renderer.domElement);
  }

  _initLocalizers() {
    this.localizerHelper = null;
    this.localizerScene = new THREE.Scene();
  }

  _initLayerMix() {
    this.sceneLayerTextureTarget = new THREE.WebGLRenderTarget(this._container.clientWidth, this._container.clientHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat
    });
    this.sceneLayer2TextureTarget = new THREE.WebGLRenderTarget(this._container.clientWidth, this._container.clientHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat
    }); // Create the Mix layer

    this.uniformsLayerMix = MixShadersUniform.uniforms();
    this.uniformsLayerMix.uTextureBackTest0.value = this.sceneLayerTextureTarget.texture;
    this.uniformsLayerMix.uTextureBackTest1.value = this.sceneLayer2TextureTarget.texture;
    this.uniformsLayerMix.uTrackMouse.value = 1;
    this.uniformsLayerMix.uMouse.value = new THREE.Vector2(0, 0);
    this.uniformsLayerMix.uMixMode.value = this.mixMode; // generate shaders on-demand!

    let fls = new MixShaderFragment(this.uniformsLayerMix);
    let vls = new AMI.LayerVertexShader();
    this.materialLayerMix = new THREE.ShaderMaterial({
      side: THREE.DoubleSide,
      uniforms: this.uniformsLayerMix,
      vertexShader: vls.compute(),
      fragmentShader: fls.compute(),
      transparent: true
    }); // mesh and scene

    this.meshLayerMix = null;
    this.sceneLayerMix = new THREE.Scene();
  }

  _initContours() {
    this.clipPlane = new THREE.Plane(new THREE.Vector3(0, 0, 0), 0); // texture target for offline rendering

    this._contourTextureTarget = new THREE.WebGLRenderTarget(this._container.clientWidth, this._container.clientHeight, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat
    }); // material

    const uniformsLayerMix = AMI.ContourUniformShader.uniforms();
    uniformsLayerMix.uTextureFilled.value = this._contourTextureTarget.texture;
    uniformsLayerMix.uWidth.value = 1.0;
    uniformsLayerMix.uCanvasWidth.value = this._contourTextureTarget.width;
    uniformsLayerMix.uCanvasHeight.value = this._contourTextureTarget.height;
    const fls = new AMI.ContourFragmentShader(uniformsLayerMix);
    const vls = new AMI.ContourVertexShader();
    this._contourMaterial = new THREE.ShaderMaterial({
      side: THREE.DoubleSide,
      uniforms: uniformsLayerMix,
      vertexShader: vls.compute(),
      fragmentShader: fls.compute(),
      transparent: true,
      extensions: {
        derivatives: true
      }
    }); // mesh and scene

    this._contourMesh = null;
    this._contourScene = new THREE.Scene();
  }

  startRenderingLoop() {
    this._animate();
  }

  stopRenderingLoop() {
    window.cancelAnimationFrame(this.animationFrameID);
    this.animationFrameID = undefined;
  }

  _animate() {
    this.animationFrameID = requestAnimationFrame(() => {
      this._animate();
    });

    this._controls.update();

    if (this._changed) {
      this._renderer.clear(); // this._renderer.render(this._scene, this._camera);
      // this._renderer.clearDepth();
      // this._renderer.render(this._scene2, this._camera);
      // this._renderer.clearDepth();
      // render first layer offscreen


      this._renderer.render(this._scene, this._camera, this.sceneLayer2TextureTarget, true); // render second layer offscreen


      this._renderer.render(this._scene2, this._camera, this.sceneLayerTextureTarget, true); // mix the layers and render it ON screen!


      this._renderer.render(this.sceneLayerMix, this._camera);

      this._renderer.clearDepth(); // contours


      if (this.contours.length >= 1 && this.stackHelper) {
        this.contours.forEach((object, key) => {
          object.materialFront.clippingPlanes = [this.clipPlane];
          object.materialBack.clippingPlanes = [this.clipPlane];

          this._renderer.render(object.scene, this._camera, this._contourTextureTarget, true);

          this._renderer.clearDepth();

          this._contourMaterial.uniforms.uWidth.value = object.selected ? 3 : 1;

          this._renderer.render(this._contourScene, this._camera);
        });
      } // localizers


      this._renderer.clearDepth();

      this._renderer.render(this.localizerScene, this._camera);

      this._changed = false;
    }
  }

  _onStackIndexChanged(index) {
    if (this.stackHelper) {
      this.stackHelper.index = index;
      if (this.stack2Helper) this.stack2Helper.index = index;

      this._updateContours();

      this._updateClipPlane();

      this._updateLayerMix();

      this._updateLocalizer();
    }
  }

  _localizersChanged(localizers) {
    if (localizers === undefined || localizers.length === 0 || this.localizerHelper === null) {
      return;
    }

    for (let c = 0; c < localizers.length; c++) {
      this.localizerHelper['plane' + (c + 1)] = localizers[c].plane;
      this.localizerHelper['color' + (c + 1)] = localizers[c].color;
    }
  }

  _updateLocalizer() {
    if (this.localizerHelper === null) {
      const stack = this.stackHelper.stack;
      const slice = this.stackHelper.slice;
      const referencePlane = slice.cartesianEquation();
      this.localizerHelper = new AMI.LocalizerHelper(stack, slice.geometry, referencePlane);
      this.localizerHelper.canvasWidth = this._container.clientWidth;
      this.localizerHelper.canvasHeight = this._container.clientHeight;
      this.localizerScene.add(this.localizerHelper);
    }

    this.localizerHelper.referencePlane = this.stackHelper.slice.cartesianEquation();
    this.localizerHelper.geometry = this.stackHelper.slice.geometry;
  }

  _updateContours() {
    if (this._contourMesh) {
      this._contourScene.remove(this._contourMesh);

      this._contourMesh.material.dispose();

      this._contourMesh.material = null;

      this._contourMesh.geometry.dispose();

      this._contourMesh.geometry = null;
    }

    this._contourMesh = new THREE.Mesh(this.stackHelper.slice.geometry, this._contourMaterial); // go to LPS space

    this._contourMesh.applyMatrix(this.stackHelper.stack._ijk2LPS);

    this._contourScene.add(this._contourMesh);
  }

  _updateLayerMix() {
    // update layer1 geometry...
    if (this.meshLayerMix) {
      this.sceneLayerMix.remove(this.meshLayerMix);
      this.meshLayerMix.material.dispose();
      this.meshLayerMix.material = null;
      this.meshLayerMix.geometry.dispose();
      this.meshLayerMix.geometry = null;
    } // add mesh in this scene with right shaders...


    this.meshLayerMix = new THREE.Mesh(this.stackHelper.slice.geometry, this.materialLayerMix); // go the LPS space

    this.meshLayerMix.applyMatrix(this.stackHelper.stack._ijk2LPS);
    this.sceneLayerMix.add(this.meshLayerMix);
  } // when index changes.


  _updateClipPlane() {
    const stackHelper = this.stackHelper;
    const camera = this._camera;
    let vertices = stackHelper.slice.geometry.vertices;
    let p1 = new THREE.Vector3(vertices[0].x, vertices[0].y, vertices[0].z).applyMatrix4(stackHelper._stack.ijk2LPS);
    let p2 = new THREE.Vector3(vertices[1].x, vertices[1].y, vertices[1].z).applyMatrix4(stackHelper._stack.ijk2LPS);
    let p3 = new THREE.Vector3(vertices[2].x, vertices[2].y, vertices[2].z).applyMatrix4(stackHelper._stack.ijk2LPS);
    this.clipPlane.setFromCoplanarPoints(p1, p2, p3);
    let cameraDirection = new THREE.Vector3(1, 1, 1);
    cameraDirection.applyQuaternion(camera.quaternion);

    if (cameraDirection.dot(this.clipPlane.normal) > 0) {
      this.clipPlane.negate();
    }
  }

  _stackSceneChanged(stackScene) {
    if (stackScene === undefined || stackScene === null || !stackScene.children) {
      return;
    }

    this._scene = stackScene;
    this.set('stackHelper', this._scene.children[0]);
    this.update();
  }

  _stack2SceneChanged(stackScene) {
    if (stackScene === undefined || stackScene === null || !stackScene.children) {
      return;
    }

    this._scene2 = stackScene;
    this.set('stack2Helper', this._scene2.children[0]);
    this.update();
  }

  update() {
    if (this.stackHelper) {
      const stack = this.stackHelper.stack;
      this.stackHelper.slice.canvasWidth = this._container.clientWidth;
      this.stackHelper.slice.canvasHeight = this._container.clientHeight;

      if (this.stack2Helper) {
        this.stack2Helper.slice.canvasWidth = this._container.clientWidth;
        this.stack2Helper.slice.canvasHeight = this._container.clientHeight;
      } // set camera


      const worldbb = stack.worldBoundingBox();
      const lpsDims = new THREE.Vector3((worldbb[1] - worldbb[0]) / 2, (worldbb[3] - worldbb[2]) / 2, (worldbb[5] - worldbb[4]) / 2); // box: {halfDimensions, center}

      const box = {
        center: stack.worldCenter().clone(),
        halfDimensions: new THREE.Vector3(lpsDims.x + 10, lpsDims.y + 10, lpsDims.z + 10)
      }; // init and zoom

      const canvas = {
        width: this._container.clientWidth,
        height: this._container.clientHeight
      };
      this._camera.directions = [stack.xCosine, stack.yCosine, stack.zCosine];
      this._camera.box = box;
      this._camera.canvas = canvas;

      this._orientationChanged(this.orientation);
    }
  }

  resize() {
    if (this.stackHelper) {
      const height = this._container.clientHeight;
      const width = this._container.clientWidth;
      const canvas = {
        width: width,
        height: height
      };
      this._camera.canvas = canvas;

      this._camera.fitBox(2, 1);

      this.sceneLayerTextureTarget.setSize(width, height);
      this.sceneLayer2TextureTarget.setSize(width, height); // TODO create personal uniform & fragment
      // this.materialLayerMix.uniforms.uCanvasWidth.value = width;
      // this.materialLayerMix.uniforms.uCanvasHeight.value = height;

      this._renderer.setSize(width, height); // update info to draw borders properly


      this.stackHelper.slice.canvasWidth = width;
      this.stackHelper.slice.canvasHeight = height;
      this.stack2Helper.slice.canvasWidth = width;
      this.stack2Helper.slice.canvasHeight = height; //

      this._contourTextureTarget.setSize(width, height);

      this._contourMaterial.uniforms.uCanvasWidth.value = width;
      this._contourMaterial.uniforms.uCanvasHeight.value = height; //

      this.localizerHelper.canvasWidth = width;
      this.localizerHelper.canvasHeight = height;
    }
  }

  _orientationChanged(orientation) {
    if (orientation === undefined || orientation === '') {
      return;
    }

    if (this.stackHelper && this.stackHelper.stack) {
      // update camera orientation
      this._camera.orientation = orientation;

      this._camera.update();

      this._camera.fitBox(2, 1); // update stack helper orientation


      this.stackOrientation = this._camera.stackOrientation;
      this.stackHelper.orientation = this.stackOrientation;
      if (this.stack2Helper) this.stack2Helper.orientation = this.stackOrientation; // update index and max index

      this.stackMaxIndex = this.stackHelper.orientationMaxIndex;
      this.stackIndex = Math.floor(this.stackMaxIndex / 2); //

      this.updateInformation();
      this.updateLabels(this._camera.directionsLabel, this.stackHelper.stack.modality);
    }
  }

  updateLabels(labels, modality) {
    if (modality === 'CR' || modality === 'DX') {
      return;
    }

    this.$.top.innerHTML = labels[0];
    this.$.bottom.innerHTML = labels[1];
    this.$.right.innerHTML = labels[2];
    this.$.left.innerHTML = labels[3];
  }

  updateInformation() {
    const stack = this.stackHelper.stack;
    const orientation = this.stackHelper.orientation;
    this.sizeX = stack._dimensionsIJK.getComponent((orientation + 1) % 2);
    this.sizeY = stack._dimensionsIJK.getComponent((orientation + 2) % 2);
  }

  _stackWindowWidthChanged(width) {
    this.set('stackHelper.slice.windowWidth', width);
    this._changed = true;
  }

  _stackWindowCenterChanged(center) {
    this.set('stackHelper.slice.windowCenter', center);
    this._changed = true;
  }

  _stack2WindowWidthChanged(width) {
    this.set('stack2Helper.slice.windowWidth', width);
    this._changed = true;
  }

  _stack2WindowCenterChanged(center) {
    this.set('stack2Helper.slice.windowCenter', center);
    this._changed = true;
  }

  _offsetChanged() {
    console.log(this.offsetX, this.offsetY, this.offsetZ);
  }

  _mixModeChanged() {
    if (this.uniformsLayerMix !== undefined) {
      this.uniformsLayerMix.uMixMode.value = this.mixMode;
      this._changed = true;
    }
  } // crossbrowser version
  // find : https://stackoverflow.com/questions/5598743/finding-elements-position-relative-to-the-document


  getContainerOffset() {
    var box = this._container.getBoundingClientRect();

    var body = document.body;
    var docEl = document.documentElement;
    var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
    var clientTop = docEl.clientTop || body.clientTop || 0;
    var clientLeft = docEl.clientLeft || body.clientLeft || 0;
    var top = box.top + scrollTop - clientTop;
    var left = box.left + scrollLeft - clientLeft;
    return {
      top: Math.round(top),
      left: Math.round(left)
    };
  }

  _onMouseMove(event) {
    if (event.shiftKey) {
      let cOffset = this.getContainerOffset();
      let mouseX = (event.clientX - cOffset.left) / this._container.clientWidth * 2 - 1;
      let mouseY = -((event.clientY - cOffset.top) / this._container.clientHeight) * 2 + 1; // push to shaders

      this.uniformsLayerMix.uMouse.value = new THREE.Vector2(mouseX, mouseY);
      this._changed = true;
    }
  }

  _onDoubleClick(event) {
    let cOffset = this.getContainerOffset();
    const mouse = {
      x: (event.clientX - cOffset.left) / this._container.clientWidth * 2 - 1,
      y: -((event.clientY - cOffset.top) / this._container.clientHeight) * 2 + 1
    };
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this._camera);
    const intersects = raycaster.intersectObject(this._scene, true);

    if (intersects.length > 0) {
      let ijk = AMI.StackModel.worldToData(this.stackHelper.stack, intersects[0].point);
      this.mouseI = ijk.x;
      this.mouseJ = ijk.y;
      this.mouseK = ijk.z;
      const goToEvent = new CustomEvent('goto', {
        detail: new THREE.Vector3(this.mouseI, this.mouseJ, this.mouseK)
      });
      this.dispatchEvent(goToEvent);
    }
  }

  _onScroll(event) {
    if (event.delta > 0) {
      if (this.stackHelper.index >= this.stackHelper.orientationMaxIndex - 1) {
        return false;
      }

      this.stackHelper.index += 1;

      if (this.stack2Helper.index >= this.stack2Helper.orientationMaxIndex - 1) {
        return false;
      }

      this.stack2Helper.index += 1;
    } else {
      if (this.stackHelper.index <= 0) {
        return false;
      }

      this.stackHelper.index -= 1;

      if (this.stack2Helper.index <= 0) {
        return false;
      }

      this.stack2Helper.index -= 1;
    }

    this.stackIndex = this.stackHelper.index;
  }

}

window.customElements.define(CompareViewer2D.is, CompareViewer2D);</script>
</dom-module>