THREE.STLLoader=function(manager){this.manager=manager!==void 0?manager:THREE.DefaultLoadingManager};THREE.STLLoader.prototype={constructor:THREE.STLLoader,load:function(url,onLoad,onProgress,onError){var scope=this,loader=new THREE.FileLoader(scope.manager);loader.setResponseType("arraybuffer");loader.load(url,function(text){try{onLoad(scope.parse(text))}catch(exception){if(onError){onError(exception)}}},onProgress,onError)},parse:function(data){var binData=function(buffer){if("string"===typeof buffer){for(var array_buffer=new Uint8Array(buffer.length),i=0;i<buffer.length;i++){array_buffer[i]=255&buffer.charCodeAt(i)}return array_buffer.buffer||array_buffer}else{return buffer}}(data);return function(data){var expect,face_size,n_faces,reader;reader=new DataView(data);face_size=3*(32/8)+3*(3*(32/8))+16/8;n_faces=reader.getUint32(80,!0);expect=80+32/8+n_faces*face_size;if(expect===reader.byteLength){return!0}for(var solid=[115,111,108,105,100],i=0;5>i;i++){if(solid[i]!=reader.getUint8(i,!1))return!0}return!1}(binData)?function(data){for(var reader=new DataView(data),faces=reader.getUint32(80,!0),r,g,b,hasColors=!1,colors,defaultR,defaultG,defaultB,alpha,index=0;index<80-10;index++){if(1129270351==reader.getUint32(index,!1)&&82==reader.getUint8(index+4)&&61==reader.getUint8(index+5)){hasColors=!0;colors=[];defaultR=reader.getUint8(index+6)/255;defaultG=reader.getUint8(index+7)/255;defaultB=reader.getUint8(index+8)/255;alpha=reader.getUint8(index+9)/255}}for(var geometry=new THREE.BufferGeometry,vertices=[],normals=[],face=0;face<faces;face++){var start=84+face*(4*12+2),normalX=reader.getFloat32(start,!0),normalY=reader.getFloat32(start+4,!0),normalZ=reader.getFloat32(start+8,!0);if(hasColors){var packedColor=reader.getUint16(start+48,!0);if(0===(32768&packedColor)){r=(31&packedColor)/31;g=(31&packedColor>>5)/31;b=(31&packedColor>>10)/31}else{r=defaultR;g=defaultG;b=defaultB}}for(var i=1,vertexstart;3>=i;i++){vertexstart=start+12*i;vertices.push(reader.getFloat32(vertexstart,!0));vertices.push(reader.getFloat32(vertexstart+4,!0));vertices.push(reader.getFloat32(vertexstart+8,!0));normals.push(normalX,normalY,normalZ);if(hasColors){colors.push(r,g,b)}}}geometry.addAttribute("position",new THREE.BufferAttribute(new Float32Array(vertices),3));geometry.addAttribute("normal",new THREE.BufferAttribute(new Float32Array(normals),3));if(hasColors){geometry.addAttribute("color",new THREE.BufferAttribute(new Float32Array(colors),3));geometry.hasColors=!0;geometry.alpha=alpha}return geometry}(binData):function(data){var geometry=new THREE.BufferGeometry,patternFace=/facet([\s\S]*?)endfacet/g,faceCounter=0,patternFloat=/[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,patternVertex=new RegExp("vertex"+patternFloat+patternFloat+patternFloat,"g"),patternNormal=new RegExp("normal"+patternFloat+patternFloat+patternFloat,"g"),vertices=[],normals=[],normal=new THREE.Vector3,result;while(null!==(result=patternFace.exec(data))){var vertexCountPerFace=0,normalCountPerFace=0,text=result[0];while(null!==(result=patternNormal.exec(text))){normal.x=parseFloat(result[1]);normal.y=parseFloat(result[2]);normal.z=parseFloat(result[3]);normalCountPerFace++}while(null!==(result=patternVertex.exec(text))){vertices.push(parseFloat(result[1]),parseFloat(result[2]),parseFloat(result[3]));normals.push(normal.x,normal.y,normal.z);vertexCountPerFace++}if(1!==normalCountPerFace){console.error("THREE.STLLoader: Something isn't right with the normal of face number "+faceCounter)}if(3!==vertexCountPerFace){console.error("THREE.STLLoader: Something isn't right with the vertices of face number "+faceCounter)}faceCounter++}geometry.addAttribute("position",new THREE.Float32BufferAttribute(vertices,3));geometry.addAttribute("normal",new THREE.Float32BufferAttribute(normals,3));return geometry}(function(buffer){if("string"!==typeof buffer){return THREE.LoaderUtils.decodeText(new Uint8Array(buffer))}return buffer}(data))}};